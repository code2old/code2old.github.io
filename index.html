<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="江湖渔民">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/04/linux-nc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="江湖渔民">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/04/linux-nc/" class="post-title-link" itemprop="url">Linux-nc命令详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-04 23:25:42" itemprop="dateCreated datePublished" datetime="2020-08-04T23:25:42+08:00">2020-08-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">Linux命令详解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Linux命令详解-netcat"><a href="#Linux命令详解-netcat" class="headerlink" title="Linux命令详解-netcat"></a>Linux命令详解-netcat</h3><p>netcat是网络工具中的瑞士军刀，它能读写网络中的TCP和UDP数据，并且可以通过重定向与其它工具结合使用，从而发挥出令人惊讶的功能。</p>
<h4 id="常用netcat命令示例"><a href="#常用netcat命令示例" class="headerlink" title="常用netcat命令示例"></a>常用netcat命令示例</h4><h5 id="1-端口扫描"><a href="#1-端口扫描" class="headerlink" title="1. 端口扫描"></a>1. 端口扫描</h5><p>netcat可以作为端口扫描工具来发现机器上开放的端口，帮助系统管理员或者黑客发现系统上存在的漏洞</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">nc -z -v -n 192.168.63.35 21-25</span></span><br></pre></td></tr></table></figure>
<p>这个命令会打印21-25所有开放的端口信息，默认为TCP模式（-u可调整为UDP模式）。<br>-z 表示0 IO，即连接成功后马上关闭连接，不进行数据交换<br>-v 表示详细输出<br>-n 表示netcat不使用DNS反向查询IP地址的域名</p>
<h5 id="2-文件传输"><a href="#2-文件传输" class="headerlink" title="2. 文件传输"></a>2. 文件传输</h5><p>Linux中有很多工具可以进行文件的网络传输，比如：FTP、Samba和scp等工具，但是ftp、samba都需要安装配置，而在一些嵌入式设备中，根本不支持scp命令。在这种情况下，可以使用netcat命令作为传输文件的桥梁进行跨机器的文件传输。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> A---&gt;B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc -l 8000 &lt; file.txt            <span class="comment"># 机器A，server端</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc -n 192.168.63.35 &gt; file.txt   <span class="comment"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>

<p>以上命令在A机器上创建了一个文件服务器，并且将文件file.txt重定向到netcat，当客户端连接到该端口时，netcat会向客户端发送file.txt的内容。而客户端B会将接收到的文件内容重定向file.txt。</p>
<p>也可以在A机器上创建文件服务器，等待客户端的连接和发送数据，并将netcat结果重定向到文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> A&lt;---B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc -l 8000 &gt; file.txt             <span class="comment"># 机器A，server端</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc 192.168.63.35 8000 &lt; file.txt  <span class="comment"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>

<h5 id="3-目录传输"><a href="#3-目录传输" class="headerlink" title="3. 目录传输"></a>3. 目录传输</h5><p>发送整个目录或者多个文件时，和发送单个文件的方式原理差不多，只不过需要使用压缩工具tar工具，然后再进行重定向即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> A---&gt;B</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -cvf - dirname | nc -l 8000           <span class="comment"># 机器A，server端</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc -n 192.168.63.35 8000 | tar -xvf -     <span class="comment"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>

<p>在A服务器上创建了一个tar的归档包并将它重定向到netcat服务器，客户端连接到服务器时，服务器便将归档数据发送给客户端，客户端netcat收到数据后再重定向到tar工具。</p>
<p>如果想要节省带宽，可以通过压缩工具压缩后再进行发送</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -cvf - dirname | bzip2 -z | nc -l 8000         <span class="comment"># 机器A，server端</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc -n 192.168.63.35 8000 | bzip2 -d | tar -xvf -   <span class="comment"># 机器B，client端</span></span></span><br></pre></td></tr></table></figure>

<p>使用tar归档和bzip2压缩和解压</p>
<h5 id="4-网络加密传输"><a href="#4-网络加密传输" class="headerlink" title="4. 网络加密传输"></a>4. 网络加密传输</h5><p>在发送数据之前，可以使用mcrypt工具保证数据安全</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nc 192.168.63.35 8000 | mcrypt --flush --bare -F -q -d -m ecb &gt; file.txt    <span class="comment"># 客户端</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mcrypt --flush --bare -F -q -m ecb &lt; file.txt | nc -l 8000   <span class="comment">#服务端</span></span></span><br></pre></td></tr></table></figure>

<p>以上两个命令都需要输入密码，而且两端使用相同的密码。这里使用mcrypt工具进行加解密，使用其他加解密工具也可以的。</p>
<p>（加密工具的用法测试的时候失败了，没有错误的打印，但是客户端输出的文件里面是空的，有知道原因的小伙伴可以交流一下）</p>
<h5 id="5-视频流"><a href="#5-视频流" class="headerlink" title="5. 视频流"></a>5. 视频流</h5><p>个人觉得用netcat发送视频流不是一个好的方法，linux上用于收发视频流的工具很多，这里只是介绍netcat发送视频流的用法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat video.mp4 | nc -l 8000</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc 192.168.63.35 8000 | mplayer -vo x11 -cache 3000 -</span></span><br></pre></td></tr></table></figure>

<p>以上命令netcat从socket中读取数据并重定向到mplayer中</p>
<h5 id="6-克隆一个设备"><a href="#6-克隆一个设备" class="headerlink" title="6. 克隆一个设备"></a>6. 克隆一个设备</h5><p>如果已经安装配置一台Linux机器并且需要对其他的机器进行同样的操作，只需要启动另一台机器的一些引导就可以克隆机器。假如系统在磁盘/dev/sda上，克隆Linux PC的操作如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dd <span class="keyword">if</span>=/dev/sda | nc -l 8000            <span class="comment"># server端</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc -n 192.168.63.35 | dd of=/dev/sda   <span class="comment"># client端</span></span></span><br></pre></td></tr></table></figure>

<p>dd是一个从磁盘读取原始数据的工具，通过netcat服务器重定向它的输出流到其他机器并且写入到磁盘中，它会随着分区表拷贝所有的信息。但是如果已经做过分区并且只需要克隆root分区，我们可以根据我们系统root分区的位置，更改sda 为sda1，sda2.等等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/04/1-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="江湖渔民">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/04/1-basic/" class="post-title-link" itemprop="url">汇编语言-基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-04 21:59:24" itemprop="dateCreated datePublished" datetime="2020-08-04T21:59:24+08:00">2020-08-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">汇编语言学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h3><h4 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h4><p>机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一些列二进制数字。计算机将之转变为一系列高低电平，以使计算机的电子器件受到驱动，进行运算。</p>
<h4 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2 汇编语言的产生"></a>1.2 汇编语言的产生</h4><p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令则是机器指令便于记忆的书写格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">操作：寄存器BX的内容送到AX中</span><br><span class="line">机器指令：1000100111011000</span><br><span class="line">汇编指令：mov ax, bx</span><br></pre></td></tr></table></figure>
<p>将汇编指令转换成机器指令的翻译程序就被称为编译器。</p>
<h4 id="1-3-汇编语言的组成"><a href="#1-3-汇编语言的组成" class="headerlink" title="1.3 汇编语言的组成"></a>1.3 汇编语言的组成</h4><p>汇编语言由以下3类指令组成：</p>
<ul>
<li>汇编指令：机器码的助记符，有对应的机器码</li>
<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>
<li>其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。<br>汇编语言的核心是机器指令，它决定了汇编语言的特性</li>
</ul>
<h4 id="1-4-存储器"><a href="#1-4-存储器" class="headerlink" title="1.4 存储器"></a>1.4 存储器</h4><p>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算。指令和数据在存储器中存放。学习汇编首先要了解CPU是如何从内存中读取信息，以及向内存中写入信息的。</p>
<h4 id="1-5-指令和数据"><a href="#1-5-指令和数据" class="headerlink" title="1.5 指令和数据"></a>1.5 指令和数据</h4><p>指令和数据都是应用上的概念。在内存和磁盘中指令和数据没有任何区别，都是二进制信息。</p>
<h4 id="1-6-存储单元"><a href="#1-6-存储单元" class="headerlink" title="1.6 存储单元"></a>1.6 存储单元</h4><p>存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号。电子计算机的最小信息单位是bit，微机存储器的容量是以字节为最小单位来计算的。</p>
<h4 id="1-7-CPU对存储器的读写"><a href="#1-7-CPU对存储器的读写" class="headerlink" title="1.7 CPU对存储器的读写"></a>1.7 CPU对存储器的读写</h4><p>CPU要想进行数据的读写，必须和外部器件进行3类信息交换：</p>
<ul>
<li>存储单元的地址（地址信息）</li>
<li>器件的选择，读或写的命令（控制信息）</li>
<li>读或写的书写（数据信息）<br>计算机中专门连接CPU和其他芯片的导线被称为总线，从逻辑上将分为3类：地址总线、控制总线和数据总线</li>
</ul>
<h4 id="1-8-地址总线"><a href="#1-8-地址总线" class="headerlink" title="1.8 地址总线"></a>1.8 地址总线</h4><p>CPU是通过地址总线来指定存储单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。一个CPU有N跟地址总线，则这个CPU的地址总线宽度为N。这样CPU最多可以对2^N个内存单元进行寻址</p>
<h4 id="1-9-数据总线"><a href="#1-9-数据总线" class="headerlink" title="1.9 数据总线"></a>1.9 数据总线</h4><p>CPU通过数据总线与其它器件进行数据交互。总线宽度决定了CPU与外界的数据传送速度。8088CPU数据总线宽度为8，一次可传送一个字节，8086CPU的数据总线宽度为16，一次可传送2个字节。</p>
<h4 id="1-10-控制总线"><a href="#1-10-控制总线" class="headerlink" title="1.10 控制总线"></a>1.10 控制总线</h4><p>CPU通过控制总线对外部器件进行控制，控制总线的宽度决定了CPU对外部器件的控制能力。</p>
<h4 id="1-11-内存地址空间概述"><a href="#1-11-内存地址空间概述" class="headerlink" title="1.11 内存地址空间概述"></a>1.11 内存地址空间概述</h4><h5 id="1-11-1-主板"><a href="#1-11-1-主板" class="headerlink" title="1.11.1 主板"></a>1.11.1 主板</h5><h5 id="1-11-2-接口卡"><a href="#1-11-2-接口卡" class="headerlink" title="1.11.2 接口卡"></a>1.11.2 接口卡</h5><p>CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作</p>
<h4 id="1-12-各类存储器芯片"><a href="#1-12-各类存储器芯片" class="headerlink" title="1.12 各类存储器芯片"></a>1.12 各类存储器芯片</h4><p>存储器从读写属性上分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，断电后存储内容丢失；只读存储器只能读取不能写，断电后内容不丢失。存储器从功能和连接上又分为以下几类：</p>
<ul>
<li>随机存储器</li>
<li>装有BIOS（Basic Input/Output System）的ROM</li>
<li>接口卡上的RAM</li>
</ul>
<h4 id="1-13-内存地址空间"><a href="#1-13-内存地址空间" class="headerlink" title="1.13 内存地址空间"></a>1.13 内存地址空间</h4><p>所有物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。8086CPU的地址总线宽度为20，可以定位2^20(1M)的内存单元，80386地址总线宽度为32，最大寻址空间为4G。8086地址空间分配基本情况如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000 |————————————————————|</span><br><span class="line">      |   主存储器地址空间  |</span><br><span class="line">      |      (RAM)         |</span><br><span class="line">9FFFF |____________________|</span><br><span class="line">A0000 |                    |</span><br><span class="line">      |    显存地址空间     |</span><br><span class="line">BFFFF |____________________|</span><br><span class="line">C0000 |                    |</span><br><span class="line">      |   各类ROM地址空间   | </span><br><span class="line">FFFFF |____________________|</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>汇编指令是机器指令的助记符，同机器指令一一对应</li>
<li>每一种CPU都有自己的汇编指令集</li>
<li>CPU直接使用的信息存放在存储器中</li>
<li>在存储中指令和数据没有任何区别，都是二进制信息</li>
<li>存储单元从0开始顺序编号</li>
<li>一个存储单元可以存储8个bit，即8位二进制数</li>
<li>1B=8b 1KB=1024B 1MB=1024KB 1GB=1024MB</li>
<li>每一个CPU芯片都有许多管脚，这些管脚和总线相连。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能：<ul>
<li>地址总线的宽度决定了CPU的寻址能力</li>
<li>数据总线的宽度决定了CPU与其它器件进行数据传输的一次数据传输量</li>
<li>控制总线的宽度决定了CPU对系统中其它器件的控制能力</li>
</ul>
</li>
</ul>
<p>对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/04/2-register(CPU)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="江湖渔民">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/04/2-register(CPU)/" class="post-title-link" itemprop="url">汇编语言-寄存器（CPU工作原理）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-04 21:59:18" itemprop="dateCreated datePublished" datetime="2020-08-04T21:59:18+08:00">2020-08-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">汇编语言学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第二章-寄存器（CPU工作原理）"><a href="#第二章-寄存器（CPU工作原理）" class="headerlink" title="第二章 寄存器（CPU工作原理）"></a>第二章 寄存器（CPU工作原理）</h3><p>内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其它器件的联系。在CPU中：运算器进行信息处理、寄存器进行信息存储、控制器控制各种器件进行工作、内部总线连接各种器件，在它们之间进行数据传输。</p>
<p>汇编程序员通过改变各种寄存器中的内容来实现对CPU的控制。</p>
<p>8086CPU有14个寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p>
<h4 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1 通用寄存器"></a>2.1 通用寄存器</h4><p>8086CPU的所有寄存器都是16位的，可以存放2个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性数据，被称为通用寄存器。为了兼容上一代8位寄存器的CPU，8086CPU的AX、BX、CX、DX都可分为两个独立使用的8位寄存器来用：</p>
<ul>
<li>AX可分为AH和AL</li>
<li>BX可分为BH和BL</li>
<li>CX可分为CH和CL</li>
<li>DX可分为DH和DL</li>
</ul>
<p>以AX为例，8086CPU的16位寄存器逻辑结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|—————————————————————————————————AX——————————————————————————————————|</span><br><span class="line">| 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span><br><span class="line">|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|</span><br><span class="line">|———————————————AH————————————————————|—————————————AL————————————————|</span><br><span class="line">| 7  | 6  | 5  | 4  | 3  |  2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span><br><span class="line">|____|____|____|____|____|____|___|___|___|___|___|___|___|___|___|___|</span><br></pre></td></tr></table></figure>

<h4 id="2-2-字在存储器中的存储"><a href="#2-2-字在存储器中的存储" class="headerlink" title="2.2 字在存储器中的存储"></a>2.2 字在存储器中的存储</h4><p>出于兼容性的考虑，8086CPU可以一次性处理两种尺寸的数据：</p>
<ul>
<li>字节：记为byte，一个字节由8个bit组成，可以存放在8位寄存器中</li>
<li>字：记为word，一个字由两个字节组成，这两个字节分别被称为这个字的高位字节和低位字节</li>
</ul>
<h4 id="2-3-几条汇编指令"><a href="#2-3-几条汇编指令" class="headerlink" title="2.3 几条汇编指令"></a>2.3 几条汇编指令</h4><p>汇编指令举例：</p>
<table>
<thead>
<tr>
<th align="left">汇编指令</th>
<th align="left">控制CPU完成的操作</th>
<th align="left">用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mov ax, 18</td>
<td align="left">将18送入寄存器AX</td>
<td align="left">AX=18</td>
</tr>
<tr>
<td align="left">mov ah, 78</td>
<td align="left">将78送入寄存器AH</td>
<td align="left">AH=18</td>
</tr>
<tr>
<td align="left">add ax,  8</td>
<td align="left">将寄存器AX中的数值加上8</td>
<td align="left">AX=AX+8</td>
</tr>
<tr>
<td align="left">mov ax, bx</td>
<td align="left">将寄存器BX中的数据送入寄存器AX</td>
<td align="left">AX=BX</td>
</tr>
<tr>
<td align="left">add ax, bx</td>
<td align="left">将AX和BX中的数值相加，结果存在AX中</td>
<td align="left">AX=AX+BX</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。</p>
<h4 id="2-4-物理地址"><a href="#2-4-物理地址" class="headerlink" title="2.4 物理地址"></a>2.4 物理地址</h4><p>CPU访问内存单元时，要给出内存单元的地址。所有构成内存单元的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，这个地址为物理地址。</p>
<h4 id="2-5-16位结构的CPU"><a href="#2-5-16位结构的CPU" class="headerlink" title="2.5 16位结构的CPU"></a>2.5 16位结构的CPU</h4><p>16位结构描述了CPU下面的几个结构特性：</p>
<ul>
<li>运算器一次最多可以处理16位数据</li>
<li>寄存器最大位宽为16位</li>
<li>寄存器和运算器之间的通路为16位</li>
</ul>
<p>也就是说：8086内部一次性处理、传输、暂存的数据最大长度为16位。</p>
<h4 id="2-6-8086CPU给出物理地址的方法"><a href="#2-6-8086CPU给出物理地址的方法" class="headerlink" title="2.6 8086CPU给出物理地址的方法"></a>2.6 8086CPU给出物理地址的方法</h4><p>8086CPU有20位地址总线，可以传送20位地址，具有1MB的寻址能力。8086CPU为16位结构，一次性处理、存储、暂存的地址为16位。</p>
<p>8086CPU采用两个16位地址合成的方法来形成一个20位的物理地址，相关部件逻辑结构如图：</p>
<div align=center>
![8086CPU相关部件的逻辑结构图](../images/assembly_2_6.png)
</div>

<p>当8086CPU要读写内存时：</p>
<ul>
<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个被称为偏移地址</li>
<li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li>
<li>地址加法器通过内部总线将20位物理地址送入输入输出控制电路</li>
<li>输入输出控制电路将20位物理地址送入地址总线</li>
<li>20位物理地址被地址总线传送到存储器</li>
</ul>
<p>地址加法器采用<strong>物理地址=段地址x16+偏移地址</strong>的方法用段地址和偏移地址合成物理地址</p>
<h4 id="2-7-“段地址x16-偏移地址-物理地址”的本质含义"><a href="#2-7-“段地址x16-偏移地址-物理地址”的本质含义" class="headerlink" title="2.7 “段地址x16+偏移地址=物理地址”的本质含义"></a>2.7 “段地址x16+偏移地址=物理地址”的本质含义</h4><p>“段地址x16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地质（段地址x16）和一个相对于基础地质的偏移地址相加，给出内存单元的物理地址。更一般的说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。</p>
<h4 id="2-8-段的概念"><a href="#2-8-段的概念" class="headerlink" title="2.8 段的概念"></a>2.8 段的概念</h4><p>内存并没有分段，段的划分来自于CPU，由于8086CPU采用“基地址（段地址x16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。所以，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16定位段的起始地址（基地址），用偏移地址定位段中的内存单元。需要注意两点：段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大是64KB。</p>
<h4 id="2-9-段寄存器"><a href="#2-9-段寄存器" class="headerlink" title="2.9 段寄存器"></a>2.9 段寄存器</h4><p>8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p>
<h4 id="2-10-CS和IP"><a href="#2-10-CS和IP" class="headerlink" title="2.10 CS和IP"></a>2.10 CS和IP</h4><p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令寄存器。</p>
<p>8086CPU中，任意时刻，CPU将CS：IP指向的内容当作指令执行</p>
<div align=center>
![8086CPU相关部件的逻辑结构图](../images/assembly_2_10.png)
</div>

<p>8086CPU的工作过程简要描述如下：</p>
<ul>
<li>从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li>
<li>IP=IP+读取指令的长度，从而指向下一条指令</li>
<li>执行指令，转到步骤1，重复这个过程</li>
</ul>
<p>在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即8086CPU刚启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086CPU开机执行的第一条指令。</p>
<p>在任何时候，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成物理地址，到内存中读取指令、执行。</p>
<h4 id="2-11-修改CS、IP的指令"><a href="#2-11-修改CS、IP的指令" class="headerlink" title="2.11 修改CS、IP的指令"></a>2.11 修改CS、IP的指令</h4><p>8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。但是，mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。</p>
<p>若想同时修改CS、IP的内容，可用指令“jmp 段地址：偏移地址”完成，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp 2AE3:3 #执行后：CS&#x3D;2AE3H，IP&#x3D;0003H，CPU将从2AE33H处读取指令</span><br><span class="line">jmp 2:0B16 #执行后：CS&#x3D;0003H，IP&#x3D;0B16H，CPU将从00B46H处读取指令</span><br></pre></td></tr></table></figure>

<p>jmp 段地址：偏移地址 指令的功能为：用指令中给出的段地址修改CS，偏移地址修改IP</p>
<p>若想仅修改IP的内容，可用指令 “jmp 某一合法寄存器”完成，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp ax, 指令执行前：ax&#x3D;1000H，CS&#x3D;2000H，IP&#x3D;0003H</span><br><span class="line">        指令执行后：ax&#x3D;1000H，CS&#x3D;2000H，IP&#x3D;1000H</span><br><span class="line">jmp bx，指令执行前：bx&#x3D;0B16H，CS&#x3D;2000H，IP&#x3D;0003H</span><br><span class="line">        指令执行后：ax&#x3D;0B16H，CS&#x3D;2000H，IP&#x3D;0B16H</span><br></pre></td></tr></table></figure>

<p>指令“jmp 某一合法寄存器”的功能为：用寄存器中的值修改IP。jmp ax，在含以上类似于mov IP, ax这样的指令</p>
<h4 id="2-12-代码段"><a href="#2-12-代码段" class="headerlink" title="2.12 代码段"></a>2.12 代码段</h4><p>将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS：IP执行的内存单元中的内容为指令。</p>
<p>要让CPU执行我们放在代码段中的指令，必须要将CS：IP指向所定义的代码段中的第一条指令的首地址。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址</li>
<li>CPU存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行</li>
<li>8086CPU的工作过程<ul>
<li>从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>
<li>IP指向下一条指令；</li>
<li>执行指令。（转到步骤（1），重复这个过程）</li>
</ul>
</li>
<li>8086CPU提供转移指令修改CS、IP的内容</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/04/3-register(Memory)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="江湖渔民">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/04/3-register(Memory)/" class="post-title-link" itemprop="url">汇编语言-寄存器（内存访问）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-04 21:59:13" itemprop="dateCreated datePublished" datetime="2020-08-04T21:59:13+08:00">2020-08-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">汇编语言学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第三章-寄存器（内存访问）"><a href="#第三章-寄存器（内存访问）" class="headerlink" title="第三章 寄存器（内存访问）"></a>第三章 寄存器（内存访问）</h3><h4 id="3-1-内存中字的存储"><a href="#3-1-内存中字的存储" class="headerlink" title="3.1 内存中字的存储"></a>3.1 内存中字的存储</h4><p>CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元存放。这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。</p>
<p>字单元，即存放一个字型数据（16）位。由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。</p>
<h4 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2 DS和[address]"></a>3.2 DS和[address]</h4><p>8080CPU中通常用DS寄存器来存放要访问数据的段地址。例如读取10000H单元中的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx, 1000H</span><br><span class="line">mov ds, bx</span><br><span class="line">mov al, [0]</span><br></pre></td></tr></table></figure>

<p>上面三条指令将10000H(1000:0)中的数据读到al中。</p>
<p><code>mov al [0]</code>中“[…]”表示一个内存单元，”[…]”中的0表示内存单元的偏移地址。指令执行时，8086CPU自动取DS寄存器中的数据为内存单元的段地址。</p>
<p>8086CPU不支持数据直接送入段寄存器操作，DS是一个段寄存器，所以mov ds, 1000H这条指令是非法的。所以只能用一个寄存器进行中转。</p>
<h4 id="3-3-字的传送"><a href="#3-3-字的传送" class="headerlink" title="3.3 字的传送"></a>3.3 字的传送</h4><p>因为8086CPU是16位结构，有16位数据线，所以可以一次性传送16位数据。</p>
<h4 id="3-4-mov、add、sub指令"><a href="#3-4-mov、add、sub指令" class="headerlink" title="3.4 mov、add、sub指令"></a>3.4 mov、add、sub指令</h4><p>mov指令可以有以下几种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器, 数据        # mov ax,  8</span><br><span class="line">mov 寄存器, 寄存器      # mov ax,  bx</span><br><span class="line">mov 寄存器, 内存单元    # mov ax,  [0]</span><br><span class="line">mov 内存单元, 寄存器    # mov [0], ax</span><br><span class="line">mov 段寄存器, 寄存器    # mov ds,  ax</span><br><span class="line">mov 寄存器, 段寄存器    # mov ax,  ds</span><br></pre></td></tr></table></figure>

<h4 id="3-5-数据段"><a href="#3-5-数据段" class="headerlink" title="3.5 数据段"></a>3.5 数据段</h4><p>对于8086CPU机，在编程时，可以根据需要将一组内存单元定义为一个段。我们可以将一组长度为N(N&lt;=64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义一个数据段。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 123BH</span><br><span class="line">mov ds, ax          ;将123BH送入DS中，作为数据段的段地址</span><br><span class="line">mov al, 0           ;用al存放累加结果</span><br><span class="line">add al, [0]         ;将数据段第一个单元(偏移地址为0)中的数值加到al中</span><br><span class="line">add al, [1]         ;将数据段第一个单元(偏移地址为1)中的数值加到al中</span><br><span class="line">add al, [2]         ;将数据段第一个单元(偏移地址为2)中的数值加到al中</span><br></pre></td></tr></table></figure>

<h4 id="3-6-栈"><a href="#3-6-栈" class="headerlink" title="3.6 栈"></a>3.6 栈</h4><p>研究角度：栈是一种具有特殊访问方式的内存空间，有两个基本操作：入栈和出栈：LIFO（Last In First Out， 后进先出）。</p>
<h4 id="3-7-CPU提供的栈机制"><a href="#3-7-CPU提供的栈机制" class="headerlink" title="3.7 CPU提供的栈机制"></a>3.7 CPU提供的栈机制</h4><p>当今的CPU中都有栈的设计。8086CPU也提供相关的指令来以栈的方式访问内存空间。基于8086CPU编程时，可以将一段内存当作栈来使用。</p>
<p>8086CPU提供入栈和出栈的指令，最基本的两个是PUSH（入栈）和POP出栈。8086CPU的入栈和出栈操作都是以字为单位进行的。</p>
<p>8086CPU中，段寄存器SS和寄存器SP，站定的段地址存放在SS中，偏移地址存放在SP中，任意时刻：SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。</p>
<p>执行push ax时，分以下两步完成：</p>
<ul>
<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶</li>
<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶</li>
</ul>
<p>执行popax时，分以下两步完成：</p>
<ul>
<li>将SS:SP指向的内存单元送入ax中</li>
<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</li>
</ul>
<h4 id="3-8-栈顶超界问题"><a href="#3-8-栈顶超界问题" class="headerlink" title="3.8 栈顶超界问题"></a>3.8 栈顶超界问题</h4><p>8086CPU不保证我们对栈的操作不会越界。8086CPU只知道栈顶在何处(由SS:SP指示)，而不知道我们安排的站空间多大。8068CPU的工作机理：它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。</p>
<p>我们在编程时要注意栈顶超界问题，根据可能用到的最大栈空间来安排栈的大小。防止入栈和出栈操作导致的栈越界。</p>
<h4 id="3-9-push、pop指令"><a href="#3-9-push、pop指令" class="headerlink" title="3.9 push、pop指令"></a>3.9 push、pop指令</h4><p>push和pop指令可以在寄存器和内存之间传送数据。push和pop指令可以是以下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 寄存器&#x2F;段寄存器&#x2F;内存单元     ;可以将一个寄存器&#x2F;段寄存器&#x2F;内存单元中的数据入栈</span><br><span class="line">pop 寄存器&#x2F;段寄存器&#x2F;内存单元      ;出栈，用一个寄存器&#x2F;段寄存器&#x2F;内存单元收出栈的数据</span><br></pre></td></tr></table></figure>
<p>指令执行时，CPU要知道内存单元的地址，可以在push/pop指令中给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中获得</p>
<p>push、pop实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。</p>
<p>push和pop指令不同于mov指令的地方在于：CPU执行mov指令只需要一步操作(传送);执行push、pop指令需要两部操作。执行push时，CPU的两部操作：先改变SP，后向SS:SP处传送数据。执行pop时，CPU先读取SS:SP处的数据，后改变SP。</p>
<p>push，pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。</p>
<h4 id="3-10-栈段"><a href="#3-10-栈段" class="headerlink" title="3.10 栈段"></a>3.10 栈段</h4><p>8086机中，根据需要将一组内存单元定义为一个段。我们可以将长度为N（N&lt;=64K）的一组地址连续、起始地址为16的倍数的内存单元当作栈空间用，从而定义一个栈段</p>
<h4 id="段的描述"><a href="#段的描述" class="headerlink" title="段的描述"></a>段的描述</h4><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址方位段内的单元。这完全是我们自己的安排。</p>
<ul>
<li>用一个段存放数据，则将它定义为“数据段”</li>
<li>用一个段存放代码，则将它定义为“代码段”</li>
<li>用一个段存放栈，则将它定义为“栈段”</li>
</ul>
<p>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问</p>
<p>对于代码段，将它的段地址放在CS中，将段中的第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令</p>
<p>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作时，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来使用</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>字在内存中存储时，要用两个连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中</p>
</li>
<li><p>用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中</p>
</li>
<li><p>[address]表示一个偏移地址为address的内存单元</p>
</li>
<li><p>在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应</p>
</li>
<li><p>mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令</p>
</li>
<li><p>8086CPU提供了栈操作机制，方案如下：</p>
<ul>
<li>在SS、SP中存放栈顶的段地址和偏移地址</li>
<li>提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元</li>
</ul>
</li>
<li><p>push指令的执行步骤：2）SP=SP-2；2）向SS:SP指向的字单元中送入数据</p>
</li>
<li><p>pop指令的执行步骤：2）从SS:SP指向的字单元中读取数据；2）SP=SP+2</p>
</li>
<li><p>任意时刻，SS:SP指向栈顶元素</p>
</li>
<li><p>8086CPU只记录栈顶，栈空间大小需要我们自己管理</p>
</li>
<li><p>用栈来暂存以后需要回复的寄存器的内容时，寄存器出栈的顺序和入栈的顺序相反</p>
</li>
<li><p>push、pop实质上是一种内存传送指令</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/04/4-first-program/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="江湖渔民">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/04/4-first-program/" class="post-title-link" itemprop="url">汇编语言-第一个程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-04 21:59:08" itemprop="dateCreated datePublished" datetime="2020-08-04T21:59:08+08:00">2020-08-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">汇编语言学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第四章-第1个程序"><a href="#第四章-第1个程序" class="headerlink" title="第四章 第1个程序"></a>第四章 第1个程序</h3><h4 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1 一个源程序从写出到执行的过程"></a>4.1 一个源程序从写出到执行的过程</h4><p>一个汇编语言程序从写出到最终执行的简要过程如下：</p>
<ul>
<li>第一步 编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件</li>
<li>第二步 对源程序进行编译链接，使用编译程序对源文件编译，产生目标文件；再用连接程序对目标文件进行链接，生成可在操作系统中运行的可执行文件。可执行文件中包含两部分内容<ul>
<li>程序和数据</li>
<li>相关的描述信息</li>
</ul>
</li>
<li>第三步 执行可执行文件中的程序</li>
</ul>
<h4 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2 源程序"></a>4.2 源程序</h4><p>程序4.1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">start: mov ax, 0123H</span><br><span class="line">       mov bx, 0456H</span><br><span class="line">       add ax, bx</span><br><span class="line">       add ax, ax</span><br><span class="line"></span><br><span class="line">       mov ax, 4c00H</span><br><span class="line">       int 21H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>在汇编语言中，包含两种指令：汇编指令和伪指令。汇编指令是有对应的机器码的指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，而是由编译器根据伪指令来进行相关的编译工作。</p>
<p>（1）segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。segment和ends的功能是定义一个段，segment说明一个段开始，end说明一个段结束。一个段必须有一个名称来标识。格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 其中XXX为段名</span><br><span class="line">XXX segment     ; 定义一个段，段名为XXX，这个段从此开始</span><br><span class="line">XXX ends        ; 名称为XXX的段到此结束</span><br></pre></td></tr></table></figure>

<p>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。一个源程序中所有将被计算机所处理的信息：指令、数据、栈被划分到了不同的段中</p>
<p>一个有意义的汇编程序中至少要有一个段，这个段用来存放代码</p>
<p>（2）end是一个汇编程序的结束标记。如果碰到了伪指令end，就结束对源程序的编译。所以程序结尾处要加上伪指令end，否则编译器无法知道程序何时结束 </p>
<p>（3）assume这条伪指令的含义为“假设”，它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联。</p>
<table>
<thead>
<tr>
<th>目的</th>
<th>相关指令</th>
<th>指令性质</th>
<th>指令执行者</th>
</tr>
</thead>
<tbody><tr>
<td>通知编译器一个段结束</td>
<td>段名ends</td>
<td>伪指令</td>
<td>编译时，由编译器执行</td>
</tr>
<tr>
<td>通知编译器程序结束</td>
<td>end</td>
<td>伪指令</td>
<td>编译时，由编译器执行</td>
</tr>
<tr>
<td>程序返回</td>
<td>mov ax, 4c00H int 21H</td>
<td>汇编指令</td>
<td>执行时，由CPU执行</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/04/5-[bx]andloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="江湖渔民">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/04/5-%5Bbx%5Dandloop/" class="post-title-link" itemprop="url">汇编语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-04 21:59:01" itemprop="dateCreated datePublished" datetime="2020-08-04T21:59:01+08:00">2020-08-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">汇编语言学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第五章-bx-和loop指令"><a href="#第五章-bx-和loop指令" class="headerlink" title="第五章 [bx]和loop指令"></a>第五章 [bx]和loop指令</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">江湖渔民</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/code2old" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;code2old" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1814593561@qq.com" title="E-Mail → mailto:1814593561@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">江湖渔民</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
